\chapter{MoVe\_IT kc705 Tera10 firmware update}
\section{Introduction}
\noindent As explained in the previous chapters a good VHDL design, in order to improve readability and order, uses separate modules for each main task of the firmware. Each module is connected with wires (signals) to the others. The first half of this chapter will analyze the structure of the kc705 tera10 firmware, while the second half will be focused on the thesis work; this comprehends the HDL additions to the firmware, the software simulations and the test simulations on chip.
In section \ref{hardware} will be described a simple level translator built for simulation purposes while in sections \ref{testbench} and \ref{testboard} will be briefly analyzed the experimental setup.

\section{Firmware structure}
\noindent
\begin{figure}[H]
	\centering
	\includegraphics[width=0.45\linewidth]{IMG/ch4/HIERARCHY5}
	\caption{KC705 tera10 firmware structure. GbPhy= purple; tera10\_latch\_counter= yellow; tera10\_io= green; tera10\_controller= light blue; lcd\_controller= red; hardware\_controller= blue; command\_processor= grey.}
	\label{fig:tera10}
\end{figure}
\begin{itemize}
	\item \textbf{KC705 TERA10}: this is the main module, everything lives inside it, thus it contains no logic, only component declarations and port-maps. In this module can be set the firmware version ("B20C" for example) that will the displayed on the LCD.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\item \textbf{GbPhy}: the communication between FPGA and computer is done via Ethernet cable using a UDP (User Datagram Protocol). This is done via firmware and also thanks to a dedicated chip connected on the board to the RJ45 connector called "PHY".
	\newline
	PHY is an abbreviation for "physical layer" and is an electronic circuit, usually implemented as a chip (integrated circuit) mandatory to implement links between physical mediums such as copper or optical fiber. It basically converts data between a "clean" clocked digital stream form that is suitable only for very short distance communication (centimetres) and an analog form that is suitable for long range transmission (meters or more).
	The chip on the KC705 board is able to transmit data up to 1Gb/s.
	\newline
	The PHY is thus firmware controlled, in the MoVe\_IT project the reception and sending of messages is managed by another project of the Turin INFN group called GbPhy. This thesis will  not focus on how it works, but only on its main characteristics\cite{gbphy}.     
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{IMG/ch4/PHY100}
		\caption{GbPhy firmware structure}
		\label{fig:phy100}
	\end{figure}
	\noindent GbPhy provides a UDP-based Ethernet control link based on a fixed length 8 byte protocol (64 bit).
	For each 8 byte message the user can send 4 bytes of data. The data is thus divides as follow:
	\begin{itemize}
		\item command\_contents(31 downto 28) => sub-system target;
		\newline
		For this application this can be x"1" for hardware commands, x"2" for LCD commands and x"4" for Tera10 commands.
		\item command\_contents(27 downto 20) => sub-system command id;
		\newline
		Each task (or command) has an id, a name with which it can be called, an example of this is the list of commands in the \textit{Tera10 Controller} part in the next pages.
		\item command\_contents(19 downto 0) => sub-system command data;
		\newline
		This 20 bits are the data that may be needed to the firmware; for example, this can be the value of a DAC that needs to be set, or it can be a list of channels that the user wants to enable or it can also be the value of a counter that the user want to read. 
	\end{itemize} 
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
	\item \textbf{Command Processor}: this module is mainly a wrapper for every module that will be presented from now on. It also 
	redirects the commands in accord with the sub-system target.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\item \textbf{LCD Controller}: it is the module that drives the 16x2 LCD display of the board.
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\linewidth]{IMG/ch4/LCD}
		\caption{KC705 tera10 LCD output}
		\label{fig:lcd}
	\end{figure}
	\noindent This module contains multiple processes, FSMs (Finite State Machines) and a RAM module. The first FSM manages the start-up sequence for the LCD, the second does the conversion of the firmware version from hex to ASCII, a third one sends one by one the characters to the display while a fourth one manages the communications with the UDP module. In fact the firmware can not only display a fixed pre-selected banner, but also a user-sent 'message' from the pc.
	The LCD is extremely useful when working with more than one card for discriminating one from another and for keeping track of the firmware version of each board.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
	\item \textbf{Tera10 I/O}: this module contains the declaration and port-map for 24 \textit{tera10 channel coincidence} modules\cite{limardi}; each module receives as an input the data from two channels of the ABACUS2 chip, this signal is thus de-serialized with a 1GHz frequency (\textit{serdes\_clk}), ten times higher than the main clock (100MHz). The output of the de-serializer is a 10 bit bus (one for each signal) to which it is added, using a shift register, the last bit from the previous bus. This is done in order to not lose any transition (high/low) from one packet and the next one.
	\newline
	The counting of the number of pulses is done with a LUT (Look Up Table) that from a 11bit bus gives back a 3bit logic vector corresponding to the number from 0 to 1. This result is used to update a 32bit counter for each channel; in figure \ref{fig:coincidence} those are N1 for ch0 and N2 for ch1.
	\newline
	In order to count with efficiency even at high rates a previous student implemented in the firmware pile-up correction algorithms. AND and OR logic combinations between the two channels 10bit bus are done, compared with others LUTs and added to four new 32bit counters ($N_{AND}$, $T_{AND}$, $N_{OR}$ and $T_{OR}$). 
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{IMG/ch4/COINCIDENCE}
		\caption{KC705 tera10 channel coincidence architecture diagram}
		\label{fig:coincidence}
	\end{figure}
	\noindent The counters $T_{1}$, $T_{2}$, $T_{AND}$ and $T_{OR}$ contain the number of clock strokes in which one of the two channel or a logic combination of both is \textit{high}.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
	\item \textbf{Tera10 Controller}: this module is strictly connected to the previous one (\textit{Tera10 I/O}), in fact it receives every counter from the previous block and manages the data in accord to the commands sent by the user. Some of the more used and important commands are:
	\begin{itemize}
		\item x"01" \textit{reset serdes}: send reset signal for the de-serializer.
		\item x"02" \textit{reset counters}: every counter for each \textit{tera10 channel coincidence} module is set to 0.
		\item x"10" \textit{set counter enable}: to enable selected counters. This is done by dividing the channels in blocks of 16. When a 20bit data command is sent bits 18-17-16 are used to identify the block, and the next 16bit are encoded one-hot for each channel; for example, to enable channel 2 the data to be sent is \textit{0-000-0000000000000010} and to enable channel 18 the data is \textit{0-001-0000000000000100}.   
		\item x"11" \textit{read counter}: read selected counter; the firmware response is a 16bit bus, thus 2 commands are needed in order to read the entire counter; the LSB (Least Significative Bit) selects between the fist and last 16bit. For example:
		\newline
		fifo\_data(7 downto 0) = "01110110" means read ch59\_counter(15 downto 0)
		\newline
		fifo\_data(7 downto 0) = "01110111" means read ch59\_counter(31 downto 15)
		\item x"13" \textit{read clocks}: read selected clock counter; the firmware response is a 16bit bus, thus are valid the same considerations as before.
		\item x"14" \textit{read coincidence counter}: read selected coincidence counter, the MSB (Most Significative Bit) selects between \textit{AND} and \textit{OR} counters; the firmware response is a 16bit buss. for example:
		\newline
		fifo\_data(7 downto 0) = "10000010" means read ch0203\_or\_counter(15 downto 0)
		\item x"15" \textit{read coincidence clocks}: read selected clock coincidence counter, the MSB (Most Significative Bit) selects between \textit{AND} and \textit{OR} counters; the firmware response is a 16bit bus.
		%\item x"18" \textit{set selected channel}:
		%\item x"20" \textit{do external trigger}:
		%\item x"12" \textit{read event buffer ram address}:
		%\item x"80" \textit{read event buffer ram}:
	\end{itemize}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
	\item \textbf{Hardware Controller}: this module manages hardware devices such as internal and external DACs, LEDs and GPIO (General Purpose Input Output) switches\&buttons. The main commands are:
	\begin{itemize}
		\item x"01" \textit{read GPIO switches}: this command returns the current state of the GPIO switches and buttons, thus:
		\newline
		reply(8 downto 4) = buttons state
		\newline
		reply(3 downto 0) = switches state
		\item x"02" \textit{set hardware LED}: this command can turn on or off LEDs.
		\item x"11" \textit{set baseline DACs}: this command is used both, for writing (setting) and reading the values of the ABACUS2 internal DACs, this will be explained in detail in section \ref{InternalDac}.
		%\item {\color{red} non so se ho detto cose sbagliate}
		\item x"20" \textit{clear external DAC}: to clear the current settings of the eternal DAC. 
		\item x"21" \textit{set external DAC data register}: to set the external DAC with the values written in the RAM.
		\item x"22" \textit{write external DAC register}: to write on memory the values to be written on the eternal DAC.
	\end{itemize}  
		
\end{itemize}
\noindent Each module contains at least two FSM (Finite State Machine) in order to properly communicate with GbPhy and the logic needed to execute its purpose. The first FSM, in figure \ref{fig:fsmFIFO1}, reads a FIFO (First Input First Output) memory in which are stored the commands received from GbPhy. If the memory is empty the logic remains in the \textit{Iddle} state until a new command is received. Once the command is selected the logic can execute it and can generate a reply string.
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{FSMdiagrams/CMDtoTERA10.pdf}
	\caption{Command to TERA10 Finite State Machine Diagram}
	\label{fig:fsmFIFO1}
\end{figure}
\noindent In order to send the data to the computer in the correct order another FIFO memory is implemented for storing all the replies strings.
The logic that writes the data into the memory is described in the FSM in figure \ref{fig:fsmFIFO2}.
%This is done in the \textit{Send Reply} state.
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{FSMdiagrams/TERA10controll.pdf}
	\caption{TERA10 control Finite State Machine}
	\label{fig:fsmFIFO2}
\end{figure}  

\section{Firmware update}
My work on the KC705 Firmware can be divided into three parts:
\begin{itemize}
	\item The implementation of the logic for the configuration of the ABACUS\_v2 internal DACs, in section \ref{InternalDac}. 
	\item The addition of a latch logic in order to save into a register the current state of every counter in the firmware, in section \ref{Latch}.
	\item The addition of a timestamp generator to obtain a more precise calculation of the proton rate, in section \ref{Timestamp}. 
\end{itemize}

\subsection{Hardware controller}\label{InternalDac}
\noindent The internal DACs of the ABACUS\_v2 chip can be described as in figure \ref{fig:internaldac}, thus as a module with 3 inputs (clock, data\_IN and reset) and an output (data\_OUT)\cite{dac}.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{IMG/ch4/INTERNALDAC}
	\caption{Internal fine tuning DACs module representation}
	\label{fig:internaldac}
\end{figure}
\noindent The 24 threshold fine tuning DACs are controlled by 24 5-bits registers. These registers can be independently
loaded and read-out via a serial interface protocol based on 16-bits words. The commands are send via a Serial
INput pin (SIN) and the data are read-out on a Serial OUTput pin (SOUT). The two serial streams are
synchronous to the CLK clock input and are sampled on the clock rising edge.
\newline
The write operations are performed according to the following sequence:
\begin{itemize}
	\item Send start sequence : 0xA5A5 = 0b1010010110100101
	\item Send write command : 11a$_{13}$a$_{12}$a$_{11}$a$_{10}$a$_{9}$a$_{8}$d$_{7}$d$_{6}$d$_{5}$d$_{4}$d$_{3}$d$_{2}$d$_{1}$d$_{0}$ with:
	\begin{itemize}
		\item 11 = write command
		\item a$_{13}$ $\rightarrow$ a$_{8}$ = 6 bit address. a$_{13}$ $\rightarrow$ a$_{9}$ is the channel address (with reference to the physical layout, address 0 is the leftmost channel and 23 is the rightmost one), while a$_{8}$ selects the VTH+ (when 1) or the VTH- DAC (when 0); this function is not used for this version of the ABACUS chip. Addresses from 24 to 31 are not used.
		\item d$_{7}$ $\rightarrow$ d$_{0}$ = 8 bit data. The bits d$_{5}$ $\rightarrow$ d$_{0}$ are the data to be written in the DAC registers (from 0 to 63); the two MSBs (d$_{7}$d$_{6}$) are not used.
	\end{itemize}
\end{itemize}
\noindent The read operations are performed as follows :
\begin{itemize}
	\item Send start sequence : 0xA5A5 = 0b1010010110100101
	\item Send read command : 10a$_{13}$a$_{12}$a$_{11}$a$_{10}$a$_{9}$a$_{8}$00x$_{5}$x$_{4}$x$_{3}$x$_{2}$x$_{1}$x$_{0}$ with:
	\begin{itemize}
		\item 10 = read command
		\item a$_{13}$ $\rightarrow$ a$_{8}$ = 6 bit address.
		\item 00x$_{5}$ $\rightarrow$ x$_{0}$. With x = DON'T CARE 
	\end{itemize}
	\item The serial output is a 16 bits word with format 11a$_{13}$a$_{12}$a$_{11}$a$_{10}$a$_{9}$a$_{8}$00d$_{5}$d$_{4}$d$_{3}$d$_{2}$d$_{1}$d$_{0}$ with:
	\begin{itemize}
		\item 11 = response of successful reading.
		\item a$_{13}$ $\rightarrow$ a$_{8}$ = confirmation of the reading address.
		\item d$_{5}$d$_{4}$d$_{3}$d$_{2}$d$_{1}$d$_{0}$ = 6~bit word of data.
	\end{itemize}
\end{itemize}
\noindent After any operation (write or read) send a 00x$_{13}$x$_{12}$x$_{11}$x$_{10}$x$_{9}$x$_{8}$x$_{7}$x$_{6}$x$_{5}$x$_{4}$x$_{3}$x$_{2}$x$_{1}$x$_{0}$. With x = DON'T CARE
\subsubsection{Configuration logic}
In order to configure the internal DACs of the ABACUS\_v2 chip 16 bits words are needed. The UDP protocol implemented with the GbPhy project give the user the possibility to send 20 bits of data.
Therefore the data was divided as follows:
\begin{itemize}
	\item 3 bits ( data19 $\rightarrow$ data17 ) not used
	\item 2 bits ( data16 $\rightarrow$ data15 ) command
	\item 6 bits ( data14 $\rightarrow$ data9 ) address
	\item 8 bits ( data8 $\rightarrow$ data1 ) DAC data
	\item 1 bit ( data0 ) DAC select
\end{itemize}
\noindent The already written hardware controller module had a command and a logic for the configuration of the internal DACs of the original ABACUS chip.
The first version of the chip didn't had an address based DAC, but a long shift-register that did not worked properly.
I decided to maintain the same sub-system command id of the previous version and completely rewrite the FSM that sends the data. 
In figure \ref{fig:fsmDACs} it can be seen the new logic diagram.
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{FSMdiagrams/InternalDACsFSM.pdf}
	\caption{FSM for the configuration of the internal fine tuning DACs of the ABACUS\_v2 chip}
	\label{fig:fsmDACs}
\end{figure}
\noindent The FSM runs into an independent process that sends to the chip 64 clock strokes, in the first 32 the data is sent, while in the remaining 32 the firmware is waiting for a response from the the ASIC.
In figure \ref{fig:fsmDACs} the two operations are divided into two red clusters.
By examining the finite state machine it can be observed that:
\begin{itemize}
	\item \textbf{Iddle}: when an internal DAC configuration command is received the logic of the FSM in figure \ref{fig:fsmFIFO1} will turn \textit{high} a signal in order to trigger this process (\textit{set\_baseline\_dacs}), thus the state of this machine will go from \textit{Iddle} to \textit{WaitFirstClock} on the first rising edge of the 125~MHz clock.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMiddle}
		\caption{}
		\label{fig:fsmiddle}
	\end{figure} 
	\item \textbf{Wait first clock}: in order to generate the \textit{sck} (serial clock for the internal dacs) the logic uses a 12~bit (\textit{baseline\_clk\_div\_ctrl}) counter that generates a signal (\textit{baseline\_clk\_div}) each time it is full, thus it counts \textit{FFF}.
	\newline To be noted that the state of the \textit{baseline\_dac\_state} does not change immediately after the counter reaches \textit{FFF}, this is not a problem since this delay is always the same and thus it does not affect the logic.
	\newline The process that runs the counter is independent from the FSM, it runs always. In order to sync the counter and the logic it was implemented a state that waits until the counter resets to 0. This can be seen in figure \ref{fig:fsmwaitfirstclock}. 
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMwaitfirstclock}
		\caption{}
		\label{fig:fsmwaitfirstclock}
	\end{figure}
	\item \textbf{Set Data}: with the first \textit{setData} state it starts the first cluster (sending data to the chip). The initial 16~bits are coded into the firmware and are always the same \textit{0xA5A5}.
	The \textit{setData} state waits until a \textit{baseline\_clk\_div} signal (when the counter resets) and then drives the \textit{baseline\_dac\_mosi} (Master Output Slave Input; data from the FPGA to the chip) signal accordingly to the data. When the signal is sent the FSM also change state to \textit{setClock}.
	This can be seen in figure \ref{fig:fsmsetdata}. 
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMsetdata}
		\caption{}
		\label{fig:fsmsetdata}
	\end{figure}
	\item \textbf{Set Clock}: the generation of the \textit{baseline\_dac\_sck} works on the same principle. When the counter resets the FSM changes state and the clock output is driven \textit{high}.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMsetclock}
		\caption{}
		\label{fig:fsmsetclock}
	\end{figure}
	\item \textbf{Clear Clock}: The clock signal is now \textit{high} and the data was previously setted, thus it can be assumed that chip sampled correctly the information. At this point, again, when the counter resets itself the FSM changes state and the clock signal goes \textit{low}.
	\newline It is important to observe that from the end of \textit{setClock} to the end of \textit{clearClock} it passes 1 counter cycle, however from the end of \textit{clearClock} to the end of \textit{setClock} it passes 2 counter cycles. This leads to a clock signal with 33\% duty cycle that is perfectly fine for the ABACUS\_v2 chip.
	The FSM clock has a 8~ns period, the counter has 12~bits and resets itself when it is full. Thus, since 0xFFF~=~4095, it can be calculated that a counter cycles lasts 32,76~$\mu$s~=~8~ns$\cdot$4095. The theoretic clock period of the internal DACs should be three times this value, therefore 98,28~$\mu$s. It will be shown if section \ref{dactests} that this is perfectly correct.     
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMnextbit}
		\caption{}
		\label{fig:fsmnextbit}
	\end{figure}
	\item \textbf{Next Bit}: inside the FSM there is a 5~bit counter (\textit{baseline\_dac\_bit\_ctrl}) that keeps trace of the number of bits sent to the chip. the \textit{nextBit} state checks this value; if the number of clocks (data in) is less than 32 the logic keeps sending data, like in figure \ref{fig:fsmcluster1}, if the number of clocks is 32 the logic start the ending communication sequence, like in figure \ref{fig:fsmendcommunication}.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMcluster1}
		\caption{}
		\label{fig:fsmcluster1}
	\end{figure}
	\item \textbf{End Communication}: with the \textit{EndCommunication} state it starts the seconds cluster of the FSM in figure \ref{fig:fsmDACs}, thus "ending communication and receiving data from ABACUS". This state performs the same tasks as \textit{nextBit}, therefore it checks if \textit{baseline\_dac\_bit\_ctrl}<32. If the condition is true the logic switches to \textit{SetDataEndCommunication}, if the condition is false the logic returns to iddle. 
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMendcommunication}
		\caption{}
		\label{fig:fsmendcommunication}
	\end{figure}
	\item \textbf{Set Data End Communication}: this state keeps the output (\textit{baseline\_dac\_mosi}) always \textit{low}.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMsetdataendcommunication}
		\caption{}
		\label{fig:fsmsetdataendcommunication}
	\end{figure}
	\item \textbf{Set Clock End Communication}: as for the \textit{setClock} state, when the 12~bit counter resets it drives \textit{high} the ABACUS\_v2 clock signal.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMsetclockendcommunication}
		\caption{}
		\label{fig:fsmsetclockendcommunication}
	\end{figure}
	\item \textbf{Clear Clock End Communication}: as for the \textit{clearClock} state, when the 12~bit counter resets it drives \textit{low} the ABACUS\_v2 clock signal.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMclearclockendcommunication}
		\caption{}
		\label{fig:fsmclearclockendcommunication}
	\end{figure}	
\end{itemize}

\noindent In figure \ref{fig:fsmalmostall} it can be seen an overview of the data sent to the chip. On the first raw the is the \textit{baseline\_clk\_div} signal that goea \textit{high} when the 12~bit counter resets. In row number three the is the \textit{baseline\_dac\_mosi} signal; this is the data in that goes inside the chip! to be noted that the first 16 bits are the start sequence 1010-0101-1010-0101. In row number four the is the \textit{baseline\_dac\_sck} signal; to be noted that the duty cycle is 33\% and that the transitions of the mosi signal are always shifted of $\approx$33~$\mu$s compared to those of the clock.
This ensures that the signal is stable before sampling.
In the fifth row there is the \textit{baseline\_dac\_bit\_ctrl} counter; to be noted that it resets after the value of 32 and after that the mosi signal is always \textit{low}.   
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMalmostall}
	\caption{}
	\label{fig:fsmalmostall}
\end{figure}
\subsubsection{Reading logic}
In order to read the data from the chip I implemented two new processes. A 16~bit shift register (\textit{shift\_register\_baseline\_dac(15 downto 0)}) and a "comparator".
The shift register receives the miso (Master Input Slave Output) signal and samples it at the falling edge of the \textit{baseline\_dac\_sck} signal. Then it stores the data into a bus that is updated each clock stroke.
The comparator look for the first 8~bits (the MSB, Most Significant Bits) of the shift register and compares them with the address of the read command received.
If \textit{shift\_register\_baseline\_dac(15 downto 8) = 11 + fifo\_data(14 downto 9)}, thus if the first 8 bits of the shift register are equal to 11+address as seen in section \ref{InternalDac} then the remaining 8 bit of the shift register are the data of the internal DAC.
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMshiftregister}
	\caption{}
	\label{fig:fsmshiftregister}
\end{figure}
\noindent In figure \ref{fig:fsmshiftregister} the read command was \textit{"000 "10" "000100" "00000000" "0"} (read command on channel 4 ) and it can be seen that when the first 8 bits of the shift register are \textit{"11000100"} it means that the last 8 bits are the data, in this case \textit{"00110011"}~=~0x33;
\newline
Simulation on board will be analysed  in section \ref{dactests}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Latching counters}\label{Latch}
\noindent As for now any counter can be read one at the time even while its counting, however this setup has some limitations. First of all it \underline{can not} read the value of two or more counters at the same time.
In second place it should me considered that it is difficult to measure the rate of particles not having two well defined points with a timestamp and the number of counted particles.
In order to solve this "problem" and to add features to the firmware I implemented a latch system that saves into a memory the current state of every counter of the firmware and generates a timestamp.
In order to do that I created a new module, called \textit{tera10\_latch\_counter} that contains all the memory and the logic needed for the latch system and for the timestamp generation. This last part will be explained in section \ref{Timestamp}.
The firmware has a total of 192 counters that needs to be latched; they are divided as follows:
\begin{itemize}
	\item 48 counters: counters
	\item 48 counters: clock counters
	\item 48 counters: AND/OR coincidence events counters
	\item 48 counters: AND/OR coincidence events clock counters
\end{itemize}
\noindent Each channel needs to be saved at the exact same time (same clock stroke), thus a deep ram block that contains every counter in a different address can not be taken into consideration.
I then decided to implement a new Block RAM IP, as in figure \ref{fig:ramip}. This new pre-configured module implements a easy to use (32x2) RAM component, thus 32~bits of data and two possible states (1~bit address). The final version of the firmware will use 192 of this components. 
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{IMG/ch4/LATCH_RAM_IP}
	\caption{Vivado IP manager summary for Latch Counters Block Memory IP}
	\label{fig:ramip}
\end{figure}
\noindent Before talking about the latch logic it is important to understand how the RAM needs to be controlled. There are a total of 8 input signals and one output:
\begin{itemize}
	\item clka and clkb: clock signal for writing and reading logic. Considering that all the logic runs on the 125~MHz \textit{tera10\_clk}, in order to avoid timing errors clka and clkb will also be 125~MHz
	\item ena and enb: enable signal for ram ports \textit{A} and \textit{B}, this signals are always \textit{high}
	\item dina: 32~bit input signal
	\item doutb: 32~bit output signal
	\item addra: 1~bit write address, this means that the ram has depth 2; two states can be latched
	\item addrb: 1~bit read address
	\item wea: \textit{write enable a}, when this signal is \textit{high} the input from dina is saved into memory at the address addra
\end{itemize} 
\noindent The \textit{tera10\_latch\_counter} receives as inputs every counter from \textit{tera10\_I/O}; each counter is then routed to the input (dina) of one ram component. When the user sends a \textit{do\_latch} command with the desired address (0 or 1) the \textit{wea} signal will turn \textit{high} for every ram implemented and thus the state of every counter will be saved.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{FSMdiagrams/latch_counter.pdf}
	\caption{Counters data flow from \textit{tera10\_I/O} to the PC}
	\label{fig:latch_counter}
\end{figure}
\noindent In order to control the block I created a new sub-system target (\textit{0x8}) dedicated to the latch and timestamp and two new FSMs with the same style as the ones in figure \ref{fig:fsmFIFO1} and \ref{fig:fsmFIFO2}. The new sub-system commands ids are:
\begin{itemize}
	\item \textit{0x0F} do latch: 
	\begin{itemize}
		\item fifo\_data(8) = write address ('0' or '1')
	\end{itemize}
	\item \textit{0x1F} read latch counters:
	\begin{itemize}
		\item fifo\_data(8) = read address ('0' or '1')
		\item fifo\_data(7 downto 1) = counter select (from 0$\rightarrow$"0000000" to 48$\rightarrow$"0110000")
		\item fifo\_data(0) = bit select $\rightarrow$ read first or last 16 bits of the counters \\('0'$\rightarrow$read~15~downto~0; '1'$\rightarrow$read~31~downto~15)
	\end{itemize}
	\item \textit{0x2F} read latch clocks:
	\begin{itemize}
		\item fifo\_data(8) = read address ('0' or '1')
		\item fifo\_data(7 downto 1) = counter select (from 0$\rightarrow$"0000000" to 48$\rightarrow$"0110000")
		\item fifo\_data(0) = bit select $\rightarrow$ read first or last 16 bits of the counters \\('0'$\rightarrow$read~15~downto~0; '1'$\rightarrow$read~31~downto~15)
	\end{itemize}
	\item \textit{0x3F} read latch coincidence counters:
	\begin{itemize}
		\item fifo\_data(8) = read address ('0' or '1')
		\item fifo\_data(7) = coincidence select ('0'$\rightarrow$read AND coincidence; '1'$\rightarrow$read OR coincidence)
		\item fifo\_data(6 downto 1) = counter select (from 0$\rightarrow$"0000000" to 24$\rightarrow$"0011000")
		\item fifo\_data(0) = bit select $\rightarrow$ read first or last 16 bits of the counters \\('0'$\rightarrow$read~15~downto~0; '1'$\rightarrow$read~31~downto~15)
	\end{itemize}
	\item \textit{0x4F} read latch coincidence clocks:
	\begin{itemize}
		\item fifo\_data(8) = read address ('0' or '1')
		\item fifo\_data(7) = coincidence select ('0'$\rightarrow$read AND coincidence; '1'$\rightarrow$read OR coincidence)
		\item fifo\_data(6 downto 1) = counter select (from 0$\rightarrow$"0000000" to 24$\rightarrow$"0011000")
		\item fifo\_data(0) = bit select $\rightarrow$ read first or last 16 bits of the counters \\('0'$\rightarrow$read~15~downto~0; '1'$\rightarrow$read~31~downto~15)
	\end{itemize}
	\item \textit{0x5F} do timestamp: see section \ref{Timestamp}
	\item \textit{0x6F} read timestamp: see section \ref{Timestamp}
\end{itemize}

\subsubsection{Vivado simulations}
\noindent In order to test the correct functioning of the latch logic I performed extensive software simulation. In figure \ref{fig:dolatch} it can be seen how the latching system works for one channel, in this case \textit{ch00}. The first signal is the 125~MHz clock then it can be seen the received packet divided in three buses that are:
\begin{itemize}
	\item fifo\_target = sub-system target
	\item fifo\_command = sub-system commands id
	\item fifo\_data = command data
\end{itemize} 
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{IMG/ch4/LATCHsimulations/DOLATCH}
	\caption{}
	\label{fig:dolatch}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{IMG/ch4/LATCHsimulations/READLATCH}
	\caption{}
	\label{fig:readlatch}
\end{figure}

\subsubsection{Implementation}
\begin{figure}[H]
	\centering
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.85\linewidth]{IMG/ch4/routed_colored_counters_clocks}
		\caption{After placement device view\\ with 96 counters latched}
		\label{fig:counters_clocks}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.85\linewidth]{IMG/ch4/routed_colored_perfect}
		\caption{After placement device view\\ with all 192 counters latched}
		\label{fig:allcounters}
	\end{minipage}
\end{figure}
\noindent It is interesting to observe how the placement of the logic changes ........

\begin{figure}[H]
	\centering
	\includegraphics[width=0.95\linewidth]{IMG/ch4/TIMING_perfect}
	\caption{}
	\label{fig:timingperfect}
\end{figure}

\subsection{Timestamp generator}\label{Timestamp}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.95\linewidth]{IMG/ch4/FIFOnearRAM}
	\caption{}
	\label{fig:fifonearram}
\end{figure}

\section{Final firmware reports}
\begin{figure}[H]
	\centering
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.85\linewidth]{IMG/ch4/FirmwareNOFLAT/DEVICE}
		\caption{}
		\label{fig:noflatdevice}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.85\linewidth]{IMG/ch4/FirmwareFLAT/DEVICE}
		\caption{}
		\label{fig:flatdevice}
	\end{minipage}
\end{figure}
\noindent To be noted that with a flat hierarchy the division between modules with different colours can not be done


\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{IMG/ch4/FirmwareNOFLAT/TIMING}
	\caption{}
	\label{fig:noflattiming}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{IMG/ch4/FirmwareFLAT/TIMING}
	\caption{}
	\label{fig:flattiming}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.9\linewidth]{IMG/ch4/FirmwareNOFLAT/POWER}
		\caption{}
		\label{fig:noflatpower}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.9\linewidth]{IMG/ch4/FirmwareFLAT/POWER}
		\caption{}
		\label{fig:flatpower}
	\end{minipage}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{IMG/ch4/FirmwareNOFLAT/UTILIZATION}
		\caption{}
		\label{fig:noflatutilization}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{IMG/ch4/FirmwareFLAT/UTILIZATION}
		\caption{}
		\label{fig:flatutilization}
	\end{minipage}
\end{figure}


