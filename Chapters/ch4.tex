\chapter{MoVe\_IT kc705 Tera10 firmware update}
\section{Introduction}
\noindent As explained in the previous chapters a good VHDL design, in order to improve readability and order, uses separate modules for each main task of the firmware. Each module is connected with wires (signals) to the others. The first half of this chapter will analyze the structure of the kc705 tera10 firmware, while the second half will be focused on the thesis work; this comprehends the HDL additions to the firmware, the software simulations and the test simulations on chip.
In section \ref{hardware} will be described a simple level translator built for simulation purposes while in sections \ref{testbench} and \ref{testboard} will be briefly analyzed the experimental setup.

\section{Firmware structure}
\noindent
\begin{figure}[H]
	\centering
	\includegraphics[width=0.45\linewidth]{IMG/ch4/HIERARCHY5}
	\caption{KC705 tera10 firmware structure. GbPhy= purple; tera10\_latch\_counter= yellow; tera10\_io= green; tera10\_controller= light blue; lcd\_controller= red; hardware\_controller= blue; command\_processor= grey.}
	\label{fig:tera10}
\end{figure}
\begin{itemize}
	\item \textbf{KC705 TERA10}: this is the main module, everything lives inside it, thus it contains no logic, only component declarations and port-maps. In this module can be set the firmware version ("B20C" for example) that will the displayed on the LCD.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\item \textbf{GbPhy}: the communication between FPGA and computer is done via Ethernet cable using a UDP (User Datagram Protocol). This is done via firmware and also thanks to a dedicated chip connected on the board to the RJ45 connector called "PHY".
	\newline
	PHY is an abbreviation for "physical layer" and is an electronic circuit, usually implemented as a chip (integrated circuit) mandatory to implement links between physical mediums such as copper or optical fiber. It basically converts data between a "clean" clocked digital stream form that is suitable only for very short distance communication (centimetres) and an analog form that is suitable for long range transmission (meters or more).
	The chip on the KC705 board is able to transmit data up to 1Gb/s.
	\newline
	The PHY is thus firmware controlled, in the MoVe\_IT project the reception and sending of messages is managed by another project of the Turin INFN group called GbPhy. This thesis will  not focus on how it works, but only on its main characteristics\cite{gbphy}.     
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{IMG/ch4/PHY100}
		\caption{GbPhy firmware structure}
		\label{fig:phy100}
	\end{figure}
	\noindent GbPhy provides a UDP-based Ethernet control link based on a fixed length 8 byte protocol (64 bit).
	For each 8 byte message the user can send 4 bytes of data. The data is thus divides as follow:
	\begin{itemize}
		\item command\_contents(31 downto 28) => sub-system target;
		\newline
		For this application this can be x"1" for hardware commands, x"2" for LCD commands and x"4" for Tera10 commands.
		\item command\_contents(27 downto 20) => sub-system command id;
		\newline
		Each task (or command) has an id, a name with which it can be called, an example of this is the list of commands in the \textit{Tera10 Controller} part in the next pages.
		\item command\_contents(19 downto 0) => sub-system command data;
		\newline
		This 20 bits are the data that may be needed to the firmware; for example, this can be the value of a DAC that needs to be set, or it can be a list of channels that the user wants to enable or it can also be the value of a counter that the user want to read. 
	\end{itemize} 
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
	\item \textbf{Command Processor}: this module is mainly a wrapper for every module that will be presented from now on. It also 
	redirects the commands in accord with the sub-system target.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\item \textbf{LCD Controller}: it is the module that drives the 16x2 LCD display of the board.
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\linewidth]{IMG/ch4/LCD}
		\caption{KC705 tera10 LCD output}
		\label{fig:lcd}
	\end{figure}
	\noindent This module contains multiple processes, FSMs (Finite State Machines) and a RAM module. The first FSM manages the start-up sequence for the LCD, the second does the conversion of the firmware version from hex to ASCII, a third one sends one by one the characters to the display while a fourth one manages the communications with the UDP module. In fact the firmware can not only display a fixed pre-selected banner, but also a user-sent 'message' from the pc.
	The LCD is extremely useful when working with more than one card for discriminating one from another and for keeping track of the firmware version of each board.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
	\item \textbf{Tera10 I/O}: this module contains the declaration and port-map for 24 \textit{tera10 channel coincidence} modules\cite{limardi}; each module receives as an input the data from two channels of the ABACUS2 chip, this signal is thus de-serialized with a 1GHz frequency (\textit{serdes\_clk}), ten times higher than the main clock (100MHz). The output of the de-serializer is a 10 bit bus (one for each signal) to which it is added, using a shift register, the last bit from the previous bus. This is done in order to not lose any transition (high/low) from one packet and the next one.
	\newline
	The counting of the number of pulses is done with a LUT (Look Up Table) that from a 11bit bus gives back a 3bit logic vector corresponding to the number from 0 to 1. This result is used to update a 32bit counter for each channel; in figure \ref{fig:coincidence} those are N1 for ch0 and N2 for ch1.
	\newline
	In order to count with efficiency even at high rates a previous student implemented in the firmware pile-up correction algorithms. AND and OR logic combinations between the two channels 10bit bus are done, compared with others LUTs and added to four new 32bit counters ($N_{AND}$, $T_{AND}$, $N_{OR}$ and $T_{OR}$). 
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{IMG/ch4/COINCIDENCE}
		\caption{KC705 tera10 channel coincidence architecture diagram}
		\label{fig:coincidence}
	\end{figure}
	\noindent The counters $T_{1}$, $T_{2}$, $T_{AND}$ and $T_{OR}$ contain the number of clock strokes in which one of the two channel or a logic combination of both is \textit{high}.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
	\item \textbf{Tera10 Controller}: this module is strictly connected to the previous one (\textit{Tera10 I/O}), in fact it receives every counter from the previous block and manages the data in accord to the commands sent by the user. Some of the more used and important commands are:
	\begin{itemize}
		\item x"01" \textit{reset serdes}: send reset signal for the de-serializer.
		\item x"02" \textit{reset counters}: every counter for each \textit{tera10 channel coincidence} module is set to 0.
		\item x"10" \textit{set counter enable}: to enable selected counters. This is done by dividing the channels in blocks of 16. When a 20bit data command is sent bits 18-17-16 are used to identify the block, and the next 16bit are encoded one-hot for each channel; for example, to enable channel 2 the data to be sent is \textit{0-000-0000000000000010} and to enable channel 18 the data is \textit{0-001-0000000000000100}.   
		\item x"11" \textit{read counter}: read selected counter; the firmware response is a 16bit bus, thus 2 commands are needed in order to read the entire counter; the LSB (Least Significative Bit) selects between the fist and last 16bit. For example:
		\newline
		fifo\_data(7 downto 0) = "01110110" means read ch59\_counter(15 downto 0)
		\newline
		fifo\_data(7 downto 0) = "01110111" means read ch59\_counter(31 downto 15)
		\item x"13" \textit{read clocks}: read selected clock counter; the firmware response is a 16bit bus, thus are valid the same considerations as before.
		\item x"14" \textit{read coincidence counter}: read selected coincidence counter, the MSB (Most Significative Bit) selects between \textit{AND} and \textit{OR} counters; the firmware response is a 16bit buss. for example:
		\newline
		fifo\_data(7 downto 0) = "10000010" means read ch0203\_or\_counter(15 downto 0)
		\item x"15" \textit{read coincidence clocks}: read selected clock coincidence counter, the MSB (Most Significative Bit) selects between \textit{AND} and \textit{OR} counters; the firmware response is a 16bit bus.
		%\item x"18" \textit{set selected channel}:
		%\item x"20" \textit{do external trigger}:
		%\item x"12" \textit{read event buffer ram address}:
		%\item x"80" \textit{read event buffer ram}:
	\end{itemize}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
	\item \textbf{Hardware Controller}: this module manages hardware devices such as internal and external DACs, LEDs and GPIO (General Purpose Input Output) switches\&buttons. The main commands are:
	\begin{itemize}
		\item x"01" \textit{read GPIO switches}: this command returns the current state of the GPIO switches and buttons, thus:
		\newline
		reply(8 downto 4) = buttons state
		\newline
		reply(3 downto 0) = switches state
		\item x"02" \textit{set hardware LED}: this command can turn on or off LEDs.
		\item x"11" \textit{set baseline DACs}: this command is used both, for writing (setting) and reading the values of the ABACUS2 internal DACs, this will be explained in detail in section \ref{InternalDac}.
		%\item {\color{red} non so se ho detto cose sbagliate}
		\item x"20" \textit{clear external DAC}: to clear the current settings of the eternal DAC. 
		\item x"21" \textit{set external DAC data register}: to set the external DAC with the values written in the RAM.
		\item x"22" \textit{write external DAC register}: to write on memory the values to be written on the eternal DAC.
	\end{itemize}  
		
\end{itemize}
\noindent Each module contains at least two FSM (Finite State Machine) in order to properly communicate with GbPhy and the logic needed to execute its purpose. The first FSM, in figure \ref{fig:fsmFIFO1}, reads a FIFO (First Input First Output) memory in which are stored the commands received from GbPhy. If the memory is empty the logic remains in the \textit{Iddle} state until a new command is received. Once the command is selected the logic can execute it and can generate a reply string.
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{FSMdiagrams/CMDtoTERA10.pdf}
	\caption{Command to TERA10 Finite State Machine Diagram}
	\label{fig:fsmFIFO1}
\end{figure}
\noindent In order to send the data to the computer in the correct order another FIFO memory is implemented for storing all the replies strings.
The logic that writes the data into the memory is described in the FSM in figure \ref{fig:fsmFIFO2}.
%This is done in the \textit{Send Reply} state.
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{FSMdiagrams/TERA10controll.pdf}
	\caption{TERA10 control Finite State Machine}
	\label{fig:fsmFIFO2}
\end{figure}  

\section{Firmware update}
My work on the KC705 Firmware can be divided into three parts:
\begin{itemize}
	\item The implementation of the logic for the configuration of the ABACUS\_v2 internal DACs, in section \ref{InternalDac}. 
	\item The addition of a latch logic in order to save into a register the current state of every counter in the firmware, in section \ref{Latch}.
	\item The addition of a timestamp generator to obtain a more precise calculation of the proton rate, in section \ref{Timestamp}. 
\end{itemize}

\subsection{Hardware controller}\label{InternalDac}
\noindent The internal DACs of the ABACUS\_v2 chip can be described as in figure \ref{fig:internaldac}, thus as a module with 3 inputs (clock, data\_IN and reset) and an output (data\_OUT)\cite{dac}.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{IMG/ch4/INTERNALDAC}
	\caption{Internal fine tuning DACs module representation}
	\label{fig:internaldac}
\end{figure}
\noindent The 24 threshold fine tuning DACs are controlled by 24 5-bits registers. These registers can be independently
loaded and read-out via a serial interface protocol based on 16-bits words. The commands are send via a Serial
INput pin (SIN) and the data are read-out on a Serial OUTput pin (SOUT). The two serial streams are
synchronous to the CLK clock input and are sampled on the clock rising edge.
\newline
The write operations are performed according to the following sequence:
\begin{itemize}
	\item Send start sequence : 0xA5A5 = 0b1010010110100101
	\item Send write command : 11a$_{13}$a$_{12}$a$_{11}$a$_{10}$a$_{9}$a$_{8}$d$_{7}$d$_{6}$d$_{5}$d$_{4}$d$_{3}$d$_{2}$d$_{1}$d$_{0}$ with:
	\begin{itemize}
		\item 11 = write command
		\item a$_{13}$ $\rightarrow$ a$_{8}$ = 6 bit address. a$_{13}$ $\rightarrow$ a$_{9}$ is the channel address (with reference to the physical layout, address 0 is the leftmost channel and 23 is the rightmost one), while a$_{8}$ selects the VTH+ (when 1) or the VTH- DAC (when 0); this function is not used for this version of the ABACUS chip. Addresses from
		24 to 31 are not used.
		\item d$_{7}$ $\rightarrow$ d$_{0}$ = 8 bit data. The bits d$_{5}$ $\rightarrow$ d$_{0}$ are the data to be written in the DAC registers (from 0 to 63); the two MSBs (d$_{7}$d$_{6}$) are not used.
	\end{itemize}
\end{itemize}
\noindent The read operations are performed as follows :
\begin{itemize}
	\item Send start sequence : 0xA5A5 = 0b1010010110100101
	\item Send read command : 10a$_{13}$a$_{12}$a$_{11}$a$_{10}$a$_{9}$a$_{8}$00x$_{5}$x$_{4}$x$_{3}$x$_{2}$x$_{1}$x$_{0}$ with:
	\begin{itemize}
		\item 10 = read command
		\item a$_{13}$ $\rightarrow$ a$_{8}$ = 6 bit address.
		\item 00x$_{5}$ $\rightarrow$ x$_{0}$. With x = DON'T CARE 
	\end{itemize}
\end{itemize}
\noindent The serial output is a 16 bits word with format 11a$_{13}$a$_{12}$a$_{11}$a$_{10}$a$_{9}$a$_{8}$00d$_{5}$d$_{4}$d$_{3}$d$_{2}$d$_{1}$d$_{0}$.
\subsubsection{Configuration logic}
In order to configure the internal DACs of the ABACUS\_v2 chip 16 bits words are needed. The UDP protocol implemented with the GbPhy project give the user the possibility to send 20 bits of data.
Therefore the data was divided as follows:
\begin{itemize}
	\item 3 bits ( data19 $\rightarrow$ data17 ) not used
	\item 2 bits ( data16 $\rightarrow$ data15 ) command
	\item 6 bits ( data14 $\rightarrow$ data9 ) address
	\item 8 bits ( data8 $\rightarrow$ data1 ) DAC data
	\item 1 bit ( data0 ) DAC select
\end{itemize}
\noindent The already written hardware controller module had a command and a logic for the configuration of the internal DACs of the original ABACUS chip.
The first version of the chip didn't had an address based DAC, but a long shift-register that did not worked properly.
I decided to maintain the same sub-system command id of the previous version and completely rewrite the FSM that sends the data. 
In figure \ref{fig:fsmDACs} it can be seen the new logic diagram.
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{FSMdiagrams/InternalDACsFSM.pdf}
	\caption{FSM for the configuration of the internal fine tuning DACs of the ABACUS\_v2 chip}
	\label{fig:fsmDACs}
\end{figure}
\noindent The FSM runs into an independent process that sends to the chip 64 clock strokes, in the first 32 the data is sent, while in the remaining 32 the firmware is waiting for a response from the the ASIC.
In figure \ref{fig:fsmDACs} the two operations are divided into two red clusters.
By examining the finite state machine it can be observed that:
\begin{itemize}
	\item \textbf{Iddle}: when an internal DAC configuration command is received the logic of the FSM in figure \ref{fig:fsmFIFO1} will turn \textit{high} a signal in order to trigger this process (\textit{set\_baseline\_dacs}), thus the state of this machine will go from \textit{Iddle} to \textit{WaitFirstClock} on the first rising edge of the 125~MHz clock.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMiddle}
		\caption{}
		\label{fig:fsmiddle}
	\end{figure} 
	\item \textbf{Wait first clock}: in order to generate the \textit{sck} (serial clock for the internal dacs) the logic uses a 12~bit (\textit{baseline\_clk\_div\_ctrl}) counter that generates a signal (\textit{baseline\_clk\_div}) each time it is full, thus it counts \textit{FFF}.
	\newline To be noted that the state of the \textit{baseline\_dac\_state} does not change immediately after the counter reaches \textit{FFF}, this is not a problem since this delay is always the same and thus it does not affect the logic.
	\newline The process that runs the counter is independent from the FSM, it runs always. In order to sync the counter and the logic it was implemented a state that waits until the counter resets to 0. This can be seen in figure \ref{fig:fsmwaitfirstclock}. 
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMwaitfirstclock}
		\caption{}
		\label{fig:fsmwaitfirstclock}
	\end{figure}
	\item \textbf{Set Data}: with the first \textit{setData} state it starts the first cluster (sending data to the chip). The initial 16~bits are coded into the firmware and are always the same \textit{0xA5A5}.
	The \textit{setData} state waits until a \textit{baseline\_clk\_div} signal (when the counter resets) and then drives the \textit{baseline\_dac\_mosi} (Master Output Slave Input; data from the FPGA to the chip) signal accordingly to the data. When the signal is sent the FSM also change state to \textit{setClock}.
	This can be seen in figure \ref{fig:fsmsetdata}. 
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMsetdata}
		\caption{}
		\label{fig:fsmsetdata}
	\end{figure}
	\item \textbf{Set Clock}: the generation of the \textit{baseline\_dac\_sck} works on the same principle. When the counter resets the FSM changes state and the clock output is driven \textit{high}.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMsetclock}
		\caption{}
		\label{fig:fsmsetclock}
	\end{figure}
	\item \textbf{Clear Clock}: The clock signal is now \textit{high} and the data was previously setted, thus it can be assumed that chip sampled correctly the information. At this point, again, when the counter resets itself the FSM changes state and the clock signal goes \textit{low}.
	\newline It is important to observe that from the end of \textit{setClock} to the end of \textit{clearClock} it passes 1 counter cycle, however from the end of \textit{clearClock} to the end of \textit{setClock} it passes 2 counter cycles. This leads to a clock signal with 33\% duty cycle that is perfectly fine for the ABACUS\_v2 chip.
	The FSM clock has a 8~ns period, the counter has 12~bits and resets itself when it is full. Thus, since 0xFFF~=~4095, it can be calculated that a counter cycles lasts 32,76~$\mu$s~=~8~ns$\cdot$4095. The theoretic clock period of the internal DACs should be three times this value, therefore 98,28~$\mu$s. It will be shown if section \ref{dactests} that this is perfectly correct.     
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMnextbit}
		\caption{}
		\label{fig:fsmnextbit}
	\end{figure}
	\item \textbf{Next Bit}:
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\linewidth]{IMG/ch4/DACsimulations/FSMcluster1}
		\caption{}
		\label{fig:fsmcluster1}
	\end{figure}
	\item \textbf{End Communication}:
	\item \textbf{Set Data End Communication}:
	\item \textbf{Set Clock End Communication}:
	\item \textbf{Clear Clock End Communication}:
	
\end{itemize}

\subsection{Latching counters}\label{Latch}

\subsection{Timestamp generator}\label{Timestamp}


